<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HK Talk</title>
  
  <subtitle>hhking&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.hhking.cn/"/>
  <updated>2018-08-23T11:30:50.950Z</updated>
  <id>https://blog.hhking.cn/</id>
  
  <author>
    <name>hhking</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Node.js 之 module.exports 和 exports</title>
    <link href="https://blog.hhking.cn/2018/08/23/exports-vs-moduleexports/"/>
    <id>https://blog.hhking.cn/2018/08/23/exports-vs-moduleexports/</id>
    <published>2018-08-23T11:13:58.000Z</published>
    <updated>2018-08-23T11:30:50.950Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fujuxtngyxj31kw11xu10.jpg" alt=""></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Node.js 模块系统是采用 CommonJS 模块规范的。每个文件视为一个独立的模块。使用 require 导入模块，使用 module.exports 和 exports 导出模块。<br>那么 module.exports 和 exports 的区别在哪里呢？</p><a id="more"></a><h2 id="module-exports"><a href="#module-exports" class="headerlink" title="module.exports"></a>module.exports</h2><ol><li>module.exports 就是 require() 的返回值</li><li>module.exports 是模块系统自动创建的，且初始化为空对象 {}</li></ol><h2 id="exports"><a href="#exports" class="headerlink" title="exports"></a>exports</h2><ol><li>exports 是为了方便快捷创建的变量，指向 module.exports 的引用</li></ol><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>可以看一下 <a href="http://nodejs.cn/api/modules.html#modules_exports_shortcut" target="_blank" rel="noopener">Node 文档</a> 中的一段解释<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params"><span class="regexp">/* ... */</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">module</span> = &#123; <span class="attr">exports</span>: &#123;&#125; &#125;;</span><br><span class="line">  (<span class="function">(<span class="params"><span class="built_in">module</span>, exports</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 模块代码在这。在这个例子中，定义了一个函数。</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">someFunc</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    exports = someFunc;</span><br><span class="line">    <span class="comment">// 此时，exports 不再是一个 module.exports 的快捷方式，</span></span><br><span class="line">    <span class="comment">// 且这个模块依然导出一个空的默认对象。</span></span><br><span class="line">    <span class="built_in">module</span>.exports = someFunc;</span><br><span class="line">    <span class="comment">// 此时，该模块导出 someFunc，而不是默认对象。</span></span><br><span class="line">  &#125;)(<span class="built_in">module</span>, <span class="built_in">module</span>.exports);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以其实两者的关系是：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exports = <span class="built_in">module</span>.exports = &#123;...&#125;</span><br></pre></td></tr></table></figure></p><p>module.exports 是一个对象，exports 是对 module.exports 的引用，即他们指向同一块内存。如图所示：<br><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fujmsr1hdfj30jk0e8dgn.jpg" alt=""></p><p>所以如果对 exports （或者 module.exports） 的对象修改，就是对他们共同指向的内存的内容做修改，两者都会影响。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这样是可以的</span></span><br><span class="line">exports.obj = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="built_in">module</span>.exports.obj = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p><p>但是如果直接将 exports (或者 module.exports) 指向一个值，则会使 exports (或者 module.exports) 指向新的内存块，等于断开了 exports 和 module.exports 的联系。下面的两种情况，导出的值要看 module.exports 的值<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接赋值 exports 是无效的，导出的模块就不是 exports 的值了</span></span><br><span class="line">exports = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;<span class="built_in">console</span>.log(x)&#125;;</span><br><span class="line"><span class="comment">// 直接赋值 module.exports 也会导致 exports 的值无法导出</span></span><br><span class="line">exports.obj = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fujnekk29fj312k0diabx.jpg" alt=""></p><p>这时候，我们可以 exports = module.exports 让 exports 重新指向 module.exports</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于 module.exports 和 exports 我们只需要记住三点就行了：</p><ol><li>module.exports 是模块系统自动创建的，且初始化为空对象 {}</li><li>require() 返回的是 module.exports 的值</li><li>exports 指向 module.exports 的引用</li></ol><p>在使用中，建议使用 module.exports 来导出模块，这样可以应对所有情况。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tNbRwgy1fujuxtngyxj31kw11xu10.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Node.js 模块系统是采用 CommonJS 模块规范的。每个文件视为一个独立的模块。使用 require 导入模块，使用 module.exports 和 exports 导出模块。&lt;br&gt;那么 module.exports 和 exports 的区别在哪里呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Node.js" scheme="https://blog.hhking.cn/categories/Node-js/"/>
    
    
      <category term="前端" scheme="https://blog.hhking.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Node" scheme="https://blog.hhking.cn/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>前端 vscode 插件推荐</title>
    <link href="https://blog.hhking.cn/2018/08/15/extensions-for-vsc/"/>
    <id>https://blog.hhking.cn/2018/08/15/extensions-for-vsc/</id>
    <published>2018-08-15T11:02:35.000Z</published>
    <updated>2018-08-21T06:25:45.055Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/extensions-for-vsc/coding.jpg" alt="images"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>工欲善其事，必先利其器</p></blockquote><p>vscode 是开源的跨平台编辑器，前端开发利器，配合丰富的插件，更是如虎添翼，效率飞升。<br>这里推荐一些目前在用的 vscode 插件，适合前端开发者。</p><a id="more"></a><ul><li><a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-close-tag" target="_blank" rel="noopener">Auto Close Tag</a><br>输入 HTML/XML 的开始标签，自动完成对应的闭合标签</li><li><a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-rename-tag" target="_blank" rel="noopener">Auto Rename Tag</a><br>修改 HTML/XML 标签时，自动完成匹配标签的修改。修改标签非常方便。</li><li><a href="https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode" target="_blank" rel="noopener">Prettier - Code formatter</a><br>使用<a href="https://github.com/prettier/prettier" target="_blank" rel="noopener">prettier</a> 格式化 JavaScript / TypeScript / CSS 代码</li><li><a href="https://marketplace.visualstudio.com/items?itemName=HookyQR.beautify" target="_blank" rel="noopener">Beautify</a><br>美化 javascript, JSON, CSS, Sass, and HTML（和Prettier二选一）</li><li><a href="https://marketplace.visualstudio.com/items?itemName=aaron-bond.better-comments" target="_blank" rel="noopener">Better Comments</a><br>让你的注释更加美观<br><img src="/images/extensions-for-vsc/better-comments.png" alt="images"></li><li><a href="https://marketplace.visualstudio.com/items?itemName=wayou.vscode-todo-highlight" target="_blank" rel="noopener">TODO Highlight</a><br>高亮 TODO, FIXME 注释，也可以自定义(和Better Comments可以二选一来使用)</li><li><a href="https://marketplace.visualstudio.com/items?itemName=alefragnani.Bookmarks" target="_blank" rel="noopener">Bookmarks</a><br>非常好用的书签功能</li><li><a href="https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer" target="_blank" rel="noopener">Bracket Pair Colorizer</a><br>不同配对括号显示不同颜色，更容易识别<br><img src="/images/extensions-for-vsc/bracket-pair-colorizer.png" alt="images"></li><li><a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner" target="_blank" rel="noopener">Code Runner</a><br>在 vscode 里直接执行代码<br><img src="/images/extensions-for-vsc/code-runner.gif" alt="images"></li><li><a href="https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker" target="_blank" rel="noopener">Code Spell Checker</a><br>拼写检查，可以避免很多 coding 过程中的拼写错误问题。强烈推荐！</li><li><a href="https://marketplace.visualstudio.com/items?itemName=anseki.vscode-color" target="_blank" rel="noopener">Color Picker</a><br>取色工具，选择颜色的时候很方便<br><img src="/images/extensions-for-vsc/color-picker.gif" alt="images"></li><li><a href="https://marketplace.visualstudio.com/items?itemName=msjsdiag.debugger-for-chrome" target="_blank" rel="noopener">Debugger for Chrome</a><br>使用 Chrome DevTools 调试 JavaScript，在 vscode 里直接打断点调试，调试 node 之类的非常方便</li><li><a href="https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens" target="_blank" rel="noopener">GitLens — Git supercharged</a><br>非常强大的 git 扩展插件</li><li><a href="https://marketplace.visualstudio.com/items?itemName=spywhere.guides" target="_blank" rel="noopener">Guides</a><br>辅助线显示</li><li><a href="https://marketplace.visualstudio.com/items?itemName=christian-kohler.npm-intellisense" target="_blank" rel="noopener">npm Intellisense</a><br>import npm modules 时候自动完成</li><li><a href="https://marketplace.visualstudio.com/items?itemName=christian-kohler.path-intellisense" target="_blank" rel="noopener">Path Intellisense</a><br>自动完成引用路径</li><li><a href="https://marketplace.visualstudio.com/items?itemName=alefragnani.project-manager" target="_blank" rel="noopener">Project Manager</a><br>项目管理插件，方便保存项目，不同项目之间切换</li><li><a href="https://marketplace.visualstudio.com/items?itemName=Shan.code-settings-sync" target="_blank" rel="noopener">Settings Sync</a><br>方便通过 GitHub Gist 在不同设备之间同步 vscode 配置</li><li><a href="https://marketplace.visualstudio.com/items?itemName=rafamel.subtle-brackets" target="_blank" rel="noopener">Subtle Match Brackets</a><br>为选中匹配的括号加上下划线，方便阅读</li><li><a href="https://marketplace.visualstudio.com/items?itemName=cssho.vscode-svgviewer" target="_blank" rel="noopener">SVG Viewer</a><br>SVG 预览</li><li><a href="https://marketplace.visualstudio.com/items?itemName=mikey.vscode-fileheader" target="_blank" rel="noopener">vscode-fileheader</a><br>国产插件，自动生成文件头部信息，比如作者，创建时间，更新时间等，并且有会自动更新，非常实用。可惜是作者很久没更新了。</li><li><a href="https://marketplace.visualstudio.com/items?itemName=zhuangtongfa.Material-theme" target="_blank" rel="noopener">One Dark Pro</a><br>非常漂亮的主题</li><li><a href="https://marketplace.visualstudio.com/items?itemName=Equinusocio.vsc-material-theme" target="_blank" rel="noopener">Material Theme</a><br>非常漂亮的主题</li><li><a href="https://marketplace.visualstudio.com/items?itemName=robertohuertasm.vscode-icons" target="_blank" rel="noopener">vscode-icons</a><br>给你的文件添加好看的 icon</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/extensions-for-vsc/coding.jpg&quot; alt=&quot;images&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;工欲善其事，必先利其器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;vscode 是开源的跨平台编辑器，前端开发利器，配合丰富的插件，更是如虎添翼，效率飞升。&lt;br&gt;这里推荐一些目前在用的 vscode 插件，适合前端开发者。&lt;/p&gt;
    
    </summary>
    
      <category term="关于前端" scheme="https://blog.hhking.cn/categories/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://blog.hhking.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="vscode" scheme="https://blog.hhking.cn/tags/vscode/"/>
    
      <category term="插件" scheme="https://blog.hhking.cn/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>浏览器的缓存机制</title>
    <link href="https://blog.hhking.cn/2018/08/10/browser-cache/"/>
    <id>https://blog.hhking.cn/2018/08/10/browser-cache/</id>
    <published>2018-08-10T06:36:08.000Z</published>
    <updated>2018-08-17T07:07:07.613Z</updated>
    
    <content type="html"><![CDATA[<p>相信很多前端都遇到过类似的情景：<br>为什么更新了内容，刷新页面没有生效？<br>被产品或测试追问：不是说问题解决了吗？为什么还是有问题？刷新也不行！</p><p>浏览器的缓存机制也就是HTTP缓存机制，是每个前端都必须理解一个点，了解浏览器缓存的机制，可以让我们在开发和排查问题中，避开很多坑；也能解释很多遇到的关于缓存的“神奇”问题；也可以针对缓存制定策略，做出优化，提升用户体验。</p><p>这里对浏览器缓存机制的学习做个总结和笔记！<br><a id="more"></a></p><h2 id="缓存的作用"><a href="#缓存的作用" class="headerlink" title="缓存的作用"></a>缓存的作用</h2><ul><li>减少网络带宽消耗</li><li>缓解服务器压力</li><li>减少网络延迟，加快网页打开速度</li></ul><h2 id="缓存过程"><a href="#缓存过程" class="headerlink" title="缓存过程"></a>缓存过程</h2><p>浏览器和服务器进行通信的方式是：浏览器发起 HTTP 请求，服务器响应请求。浏览器是怎么决定是否缓存资源、怎么缓存？根据响应头！</p><p>缓存的大致过程如下：</p><ol><li>浏览器向服务器发起请求时，会先在浏览器缓存中查找该请求的结果和缓存标识，判断是否需要向服务器发起请求；</li><li>拿到请求结果，会根据响应报文中 HTTP 头的缓存标识，决定是否缓存请求结果；</li><li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中；</li></ol><p>根据是否需要向服务器重新发起 HTTP 请求将缓存过程分成：强制缓存和协商缓存。</p><h3 id="强制缓存阶段-本地缓存"><a href="#强制缓存阶段-本地缓存" class="headerlink" title="强制缓存阶段(本地缓存)"></a>强制缓存阶段(本地缓存)</h3><h4 id="强制缓存过程"><a href="#强制缓存过程" class="headerlink" title="强制缓存过程"></a>强制缓存过程</h4><p>强制缓存阶段就是在浏览器缓存中查找请求结果和缓存标识，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。</p><p>这个阶段有三种情况：</p><ol><li><p>没有查找到请求结果和缓存标识，则强制缓存失效，这时浏览器向服务器发起 HTTP 请求(第一次发起请求就属于这种情况)<br><img src="/images/browser-cache/browser-cache1.png" alt="images"></p></li><li><p>存在缓存标识，但是缓存已失效，则强制缓存不命中，这时使用协商缓存<br><img src="/images/browser-cache/browser-cache2.png" alt="images"></p></li><li><p>存在缓存结果和缓存标识，缓存结果有效，则命中强制缓存，直接返回缓存结果<br><img src="/images/browser-cache/browser-cache3.png" alt="images"></p></li></ol><h4 id="强制缓存规则"><a href="#强制缓存规则" class="headerlink" title="强制缓存规则"></a>强制缓存规则</h4><p>在强制缓存过程中，怎么判断缓存是否有效（也就是上面的情况 2 和 3）？<br>控制强制缓存的是响应报文中 HTTP 头的 Pragma、 Expires 和 Cache-Control 字段，其中 Cache-control 优先级最高。</p><h5 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h5><p>在 HTTP/1.1 中，Cache-Control 是最重要的规则，不仅是优先级最高，而且包含了 <strong>缓存策略</strong> 和 <strong>过期策略</strong></p><p>语法为：<code>Cache-Control：cache-directive</code>，cache-directive 有如下取值(比较常见的是前五个)：</p><table><thead><tr><th>cache-directive</th><th>说明</th></tr></thead><tbody><tr><td>public</td><td>所有内容都将被缓存（客户端和代理服务器都可以缓存）</td></tr><tr><td>private</td><td>所有内容只有客户端可以缓存，代理服务器不缓存，Cache-control 的默认取值</td></tr><tr><td>no-store</td><td>所有内容都不会被缓存，既不使用强制缓存，也不使用协商缓存</td></tr><tr><td>no-cache</td><td>客户端缓存内容，但是是否使用缓存需要通过协商缓存来验证决定(相当于 max-age:0,must-revalidate)</td></tr><tr><td>max-age</td><td>缓存内容将在 xxx 秒后失效（相对值）</td></tr><tr><td>s-maxage</td><td>同上, 覆盖 max-age, 且只在代理服务器上有效, 所以依赖 public 设置</td></tr><tr><td>max-stale</td><td>指定时间内, 即使缓存过时, 资源依然有效</td></tr><tr><td>min-fresh</td><td>缓存的资源至少要保持指定时间的新鲜期</td></tr><tr><td>must-revalidation / proxy-revalidation</td><td>如果缓存失效, 强制重新向服务器(或代理)发起验证 (因为max-stale等字段可能改变缓存的失效时间)</td></tr><tr><td>only-if-cached</td><td>仅仅返回已经缓存的资源, 不向服务器请求, 若无缓存则返回504</td></tr><tr><td>no-transform</td><td>强制要求代理服务器不要对资源进行转换, 禁止代理服务器对 Content-Encoding, Content-Range, Content-Type字段的修改(因此代理的gzip压缩将不被允许)</td></tr></tbody></table><p><em>当 max-age 与 max-stale 和 min-fresh 同时使用时, 它们的设置相互之间独立生效, 但是客户端总是采用最保守的缓存策略</em></p><h5 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h5><p>Pragma 是 http/1.0 字段, 通常设置为 Pragma:no-cache, 作用同 Cache-Control:no-cache. 为了向下兼容有些网站会加上这个配置；<br>在 chrome 开发者工具 Network 中, 勾选 Disable cache 时, 浏览器会自动带上了 Pragma 字段</p><h5 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h5><p>Expires 是 HTTP/1.0 (现在浏览器默认使用的是 HTTP/1.1)控制网页缓存的字段，指定缓存到期的 GMT(格林尼治时间) 的绝对时间。<br>但是：响应报文中 Expires 所定义的缓存时间是相对服务器上的时间而言的，如果客户端的时间和服务端的时间不一致（比如用户自己修改了客户端时间），缓存时间就没有意义了。<br>为了解决这个问题，于是 HTTP/1.1 新增了 Cache-control 来定义缓存过期时间。</p><h5 id="启发式缓存"><a href="#启发式缓存" class="headerlink" title="启发式缓存"></a>启发式缓存</h5><p>如果 Expires, Cache-Control: max-age, 或 Cache-Control:s-maxage 都没有在响应头中出现, 并且也没有其它缓存的设置, 那么浏览器默认会采用一个启发式的算法:<br>通常会取响应头的两个时间字段相减 Date - Last-Modified 值的 10% 作为缓存时间。</p><h5 id="from-memory-cache-from-disk-cache"><a href="#from-memory-cache-from-disk-cache" class="headerlink" title="from memory cache/from disk cache"></a>from memory cache/from disk cache</h5><p>在 chrome 开发者工具 Network 中，我们经常会看到 200 from memory cache 或者 from disk cache ，这两个表示强制缓存成功。</p><table><thead><tr><th>200</th><th>描述</th><th>说明</th></tr></thead><tbody><tr><td>from memory</td><td>使用内存中的缓存</td><td>具有 <strong>快速读取</strong> (内存缓存会将编译解析后的文件，直接存入该进程的内存中)和 <strong>实效性</strong> (进程关闭会清空对应内存)的特点，js 和图片等文件解析执行后直接存入内存缓存中，刷新页面时只需直接从内存缓存中读取</td></tr><tr><td>from disk cache</td><td>使用硬盘中的缓存</td><td>css 文件则会存入硬盘文件中，每次渲染页面都需要从硬盘读取缓存</td></tr></tbody></table><h3 id="协商缓存阶段"><a href="#协商缓存阶段" class="headerlink" title="协商缓存阶段"></a>协商缓存阶段</h3><h4 id="协商缓存过程"><a href="#协商缓存过程" class="headerlink" title="协商缓存过程"></a>协商缓存过程</h4><p>当强制缓存未命中(缓存过期)，浏览器携带缓存标识继续向服务器发起请求，服务器根据缓存标识决定是否使用缓存，这就是 <strong>协商缓存</strong>。<br>这个过程有下面两种情况：</p><ol><li>命中协商缓存，304<br><img src="/images/browser-cache/browser-cache4.png" alt="images"></li><li>未命中协商缓存，200<br><img src="/images/browser-cache/browser-cache5.png" alt="images"></li></ol><h4 id="协商缓存规则"><a href="#协商缓存规则" class="headerlink" title="协商缓存规则"></a>协商缓存规则</h4><p>控制协商缓存的字段有 Last-Modified/If-Modified-Since 和 Etag/If-None-Match, 其中 Etag/If-None-Match 的优先级比 Last-Modified/If-Modified-Since 高</p><h4 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified/If-Modified-Since"></a>Last-Modified/If-Modified-Since</h4><ul><li>Last-Modified 是服务器响应请求时，返回该资源文件在服务器最后被修改的时间</li><li>If-Modified-Since 是客户端再次发起该请求时，携带上次请求返回的 Last-Modified 值</li></ul><p>服务器收到请求后, 拿 If-Modified-Since 字段的值与资源的 Last-Modified 值进行比较, 若相同, 则命中协商缓存, 返回304响应</p><h4 id="Etag-If-None-Match"><a href="#Etag-If-None-Match" class="headerlink" title="Etag/If-None-Match"></a>Etag/If-None-Match</h4><ul><li>Etag 是服务器响应请求时，返回当前资源文件的一个唯一标识（服务器生成）</li><li>If-None-Match 是客户端再次发起请求时，携带上次请求返回的唯一标识 Etag 值</li></ul><p>服务器收到请求后, 拿 If-None-Match 字段的值与资源的 ETag 值进行比较, 若相同, 则命中协商缓存, 返回304响应</p><h4 id="Etag-解决-Last-Modified-无法解决的一些问题"><a href="#Etag-解决-Last-Modified-无法解决的一些问题" class="headerlink" title="Etag 解决 Last-Modified 无法解决的一些问题"></a>Etag 解决 Last-Modified 无法解决的一些问题</h4><ul><li>一些文件周期性更改，但是内容不变，只改变修改时间</li><li>某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说 1s 内修改了 N 次)，If-Modified-Since 能检查到的粒度是 s 级的，这种修改无法判断(或者说 UNIX 记录 MTIME 只能精确到秒)</li><li>某些服务器不能精确的得到文件的最后修改时间</li></ul><h3 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h3><ul><li>Content-Length: 尽管并没有在缓存中明确涉及，Content-Length头部在设置缓存策略时很重要。某些软件如果不提前获知内容的大小以留出足够空间，则会拒绝缓存该内容。</li><li>Vary: 缓存系统通常使用请求的主机和路径作为存储该资源的键。当判断一个请求是否是请求同样内容是，Vary 头部可以被用来提醒缓存系统需要注意另一个附加头部。它通常被用来告诉缓存系统同样注意 Accept-Encoding 头部，以便缓存系统能够区分压缩和未压缩的内容。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一图胜千言，在实际开发中，遇到缓存问题可以按下面的过程去思考问题。<br><img src="/images/browser-cache/browser-cache.png" alt="images"></p><p>参考文章：</p><blockquote><p><a href="http://louiszhai.github.io/2017/04/07/http-cache/" target="_blank" rel="noopener">浏览器缓存机制剖析</a><br><a href="https://heyingye.github.io/2018/04/16/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">彻底理解浏览器的缓存机制</a><br><a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html" target="_blank" rel="noopener">HTTP/1.1: Header Field Definitions</a><br><a href="http://www.cnblogs.com/vajoy/p/5341664.html" target="_blank" rel="noopener">浅谈浏览器http的缓存机制</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信很多前端都遇到过类似的情景：&lt;br&gt;为什么更新了内容，刷新页面没有生效？&lt;br&gt;被产品或测试追问：不是说问题解决了吗？为什么还是有问题？刷新也不行！&lt;/p&gt;
&lt;p&gt;浏览器的缓存机制也就是HTTP缓存机制，是每个前端都必须理解一个点，了解浏览器缓存的机制，可以让我们在开发和排查问题中，避开很多坑；也能解释很多遇到的关于缓存的“神奇”问题；也可以针对缓存制定策略，做出优化，提升用户体验。&lt;/p&gt;
&lt;p&gt;这里对浏览器缓存机制的学习做个总结和笔记！&lt;br&gt;
    
    </summary>
    
      <category term="关于前端" scheme="https://blog.hhking.cn/categories/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://blog.hhking.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="浏览器缓存" scheme="https://blog.hhking.cn/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>webpack 2 配置指南</title>
    <link href="https://blog.hhking.cn/2017/03/12/webpack-guide/"/>
    <id>https://blog.hhking.cn/2017/03/12/webpack-guide/</id>
    <published>2017-03-12T09:55:05.000Z</published>
    <updated>2018-08-17T07:07:02.496Z</updated>
    
    <content type="html"><![CDATA[<p>  <img src="/images/webpack.png" alt="images"><br><em>webpack 已经更新到2.2版本。webpack v1 官方已经不推荐使用,建议更新到webpack 2。 (2017-03-12)</em></p><h2 id="四大核心概念-Four-Core-Concepts"><a href="#四大核心概念-Four-Core-Concepts" class="headerlink" title="四大核心概念 (Four Core Concepts)"></a>四大核心概念 (Four Core Concepts)</h2><p>webpack 是现代JavaScript应用的模块打包工具（module bundler），具有高度可配置性。<br>在开始配置webpack之前，我们需要先理解它的四大核心概念，有助于我们理解webpack的工具方式。</p><a id="more"></a><h3 id="1-Entry"><a href="#1-Entry" class="headerlink" title="1. Entry"></a>1. Entry</h3><p>入口文件，让webpack用哪个文件作为项目的入口。<br>入口就是webpack打包的起点，并从起点开始寻找相关的依赖，从而知道打包什么。</p><p>webpack.config.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &apos;./path/to/my/entry/file.js&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="2-Output"><a href="#2-Output" class="headerlink" title="2. Output"></a>2. Output</h3><p>出口。<br>webpack帮你把相关的资源打包好了，你需要告诉它把处理完的文件放在哪里。</p><p>webpack.config.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &apos;./path/to/my/entry/file.js&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">    filename: &apos;my-first-webpack.bundle.js&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="3-Loaders"><a href="#3-Loaders" class="headerlink" title="3. Loaders"></a>3. Loaders</h3><p>载入器（转换器）。<br>webpack 只能识别JavaScript，但是它能把各种文件(.css,.html,.scss,.jpg 等等)处理成模块，就是通过Loaders来实现的。<br>Loaders可以理解为把各种文件转换成相应的模块，提供给webpack打包使用的工具。</p><p>webpack.config.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">const config = &#123;</span><br><span class="line">  entry: &apos;./path/to/my/entry/file.js&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">    filename: &apos;my-first-webpack.bundle.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;test: /\.(js|jsx)$/, use: &apos;babel-loader&apos;&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = config;</span><br></pre></td></tr></table></figure></p><h3 id="4-Plugins"><a href="#4-Plugins" class="headerlink" title="4. Plugins"></a>4. Plugins</h3><p>插件<br>webpack的插件主要是一些对打包出来的内容做一些处理的工具（不限于此）。<br>比如：把所有的css文件抽离到一个css文件；压缩js；生成html模板等。</p><p>webpack.config.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); //installed via npm</span><br><span class="line">const webpack = require(&apos;webpack&apos;); //to access built-in plugins</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">const config = &#123;</span><br><span class="line">  entry: &apos;./path/to/my/entry/file.js&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">    filename: &apos;my-first-webpack.bundle.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;test: /\.(js|jsx)$/, use: &apos;babel-loader&apos;&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new webpack.optimize.UglifyJsPlugin(),</span><br><span class="line">    new HtmlWebpackPlugin(&#123;template: &apos;./src/index.html&apos;&#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = config;</span><br></pre></td></tr></table></figure></p><p><em>上述例子来自官方文档，详情参考<a href="https://webpack.js.org/concepts/" target="_blank" rel="noopener">Concepts</a></em></p><h2 id="webpack-2-配置"><a href="#webpack-2-配置" class="headerlink" title="webpack 2 配置"></a>webpack 2 配置</h2><h3 id="建立项目"><a href="#建立项目" class="headerlink" title="建立项目"></a>建立项目</h3><p>建一个文件夹，初始化package.json<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir webpack</span><br><span class="line">cd webpack</span><br><span class="line">npm init</span><br></pre></td></tr></table></figure></p><p><em>填入必要的内容，也可以直接回车跳过一些内容</em></p><p>建立目录结构如下</p><ul><li>/dist</li><li>/src<ul><li>index.js</li></ul></li><li>package.json</li></ul><h3 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h3><p>项目中安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack --save-dev</span><br><span class="line"></span><br><span class="line">// 指定安装某个版本</span><br><span class="line">npm install webpack@&lt;version&gt; --save-dev</span><br></pre></td></tr></table></figure></p><p>使用npm script时，npm会去寻找当前项目的modules中安装的webpack<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;webpack --config mywebpack.config.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种使用方式是推荐的最佳实践方式</p><p>你也可以选择全局安装，这样webpack命令就全局都可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack -g</span><br></pre></td></tr></table></figure></p><p><em>全局安装要注意全局安装版本和项目安装的版本不同可能导致出错。</em></p><h3 id="配置入口和出口"><a href="#配置入口和出口" class="headerlink" title="配置入口和出口"></a>配置入口和出口</h3><p>安装webpack之后，我们在根目录创建webpack.config.js文件，这是webpack默认匹配的配置文件。<br>你也可以自定义的指定某一个配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--config mywebpack.config.js</span><br></pre></td></tr></table></figure></p><p>webpack.config.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const webpack = require(&apos;webpack&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  context: path.resolve(__dirname, &apos;./src&apos;),</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: &apos;./app.js&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, &apos;./dist&apos;),</span><br><span class="line">    filename: &apos;[name].bundle.js&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>配置解释：</p><ul><li>__dirname: 指的是项目的根目录(绝对路径)</li><li>context: webpack的开始根目录(必须绝对路径)，默认为当前目录。推荐配置该属性，这样就可以让你的配置和你当前的工作目录解耦。</li><li>output.path: 输出文件目录</li><li>outputl.filename: 输出文件的名称 [name]对应于entry里的key，这里的key就是app</li></ul><p>webpack的工作流程如下：</p><ol><li>从context文件夹开始</li><li>查找entry对应文件</li><li>找到入口文件后读取内容，每当遇到 import (ES6) 或者 require() （Node） 依赖项时, 它会解析这些代码, 并且打包到最终构建里. 接着它会不断递归搜索实际需要的依赖项, 直到它到达了“树”的底部.</li><li>递归完所有依赖之后, Webpack 会将所有东西打包到 output.path 对应的目录, 并将 output.filename 的值作为最终的资源名.</li></ol><h3 id="Loaders"><a href="#Loaders" class="headerlink" title="Loaders"></a>Loaders</h3><h4 id="Babel-ES6"><a href="#Babel-ES6" class="headerlink" title="Babel+ES6"></a>Babel+ES6</h4><h5 id="install"><a href="#install" class="headerlink" title="install"></a>install</h5><p>使用ES6语法，配置Babel进行编译，需要使用<a href="https://github.com/babel/babel-loader" target="_blank" rel="noopener">babel-loader</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-loader babel-core babel-preset-es2015 --save-dev</span><br><span class="line"></span><br><span class="line">// 使用react还需要安装</span><br><span class="line">npm install react react-dom --save</span><br><span class="line">npm install babel-preset-react --save-dev</span><br></pre></td></tr></table></figure><blockquote><p>babel-preset-es2015 es6语法包<br>babel-preset-react react语法包</p></blockquote><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>loader配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  //...</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.jsx?$/,</span><br><span class="line">        use: [&#123;</span><br><span class="line">          loader: &apos;babel-loader&apos;,</span><br><span class="line">          options: &#123;</span><br><span class="line">            &quot;presets&quot;: [</span><br><span class="line">              &quot;es2015&quot;,</span><br><span class="line">              &quot;react&quot;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;],</span><br><span class="line">        exclude: [</span><br><span class="line">          path.resolve(__dirname, &quot;node_modules&quot;)</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test: 匹配的文件<br>excule: 排除node_modules目录<br>options: 这里配置的babel的配置信息</p><p>一般推荐，把babel的配置文件当初抽离到.babelrc文件中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    &quot;es2015&quot;,</span><br><span class="line">    &quot;react&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><ul><li>babel-polyfill<br>Babel默认是只转换JS的语法的，一些重要的API如Promise、WeakMap，一些静态方法Array.from或Object.assign、实例方法Array.prototype.includes以及生成器函数都是没有转换的。这个时候我们就需要该包来进行转码。polyfill是会添加到全局作用对象中去就像原生的原型String一样。<br>Babel默认不转码的API非常多，详细清单可以查看babel-plugin-transform-runtime模块的<a href="https://github.com/babel/babel/blob/master/packages/babel-plugin-transform-runtime/src/definitions.js" target="_blank" rel="noopener">definitions.js</a>。</li></ul><ul><li>如果想使用ES7的一些特性，可以使用state-0或者其他对应的包。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-preset-stage-0 --save-dev</span><br><span class="line"></span><br><span class="line">// .babelrc</span><br><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: &#123;</span><br><span class="line">    &quot;stage-0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>stage预置条件是会后向兼容的，也就是说stage-0的预置条件是会包含stage-1、stage-2、stage-3等预置条件的</p></blockquote><ul><li>修饰器使用：Babel v6移除了修饰器的支持，如果要使用，需要安装第三方插件<a href="https://github.com/loganfsmyth/babel-plugin-transform-decorators-legacy" target="_blank" rel="noopener">transform-decorators-legacy</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-plugin-transform-decorators-legacy --save-dev</span><br><span class="line"></span><br><span class="line">// .babelrc</span><br><span class="line">&#123;</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    &quot;transform-decorators-legacy&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>*详情可以查看<a href="https://babeljs.io/docs/plugins/" target="_blank" rel="noopener">Babel Plugins</a></p><h4 id="style"><a href="#style" class="headerlink" title="style"></a>style</h4><h5 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h5><p>我们需要两种loader，css-loader 和 style-loader。<br>css-loader 会遍历css文件，找到所有的url(…)并且处理。<br>style-loader 会把所有的样式插入到你页面的一个 style tag 中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.css$/,</span><br><span class="line">        use: [ &apos;style-loader&apos;, &apos;css-loader&apos; ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在css里经常会引用图片(url(../image.png))之类的，这里就css-loader是无法处理的，需要配合file-loader和url-loader来处理图片等静态资源</p><ul><li>file-loader: 将匹配到的文件复制到输出文件夹，并根据 output.publicPath 的设置返回文件路径。</li><li>url-loader: 类似file-loader ,但是它可以返回一个DataUrl (base 64)如果文件小于设置的限制值limit。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.css$/,</span><br><span class="line">        use: [ &apos;style-loader&apos;, &apos;css-loader&apos; ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(png|jpg|gif|svg|eot|ttf|woff|woff2)$/,</span><br><span class="line">        loader: &apos;url-loader&apos;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          limit: 10000</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="使用CSS-Modules"><a href="#使用CSS-Modules" class="headerlink" title="使用CSS Modules"></a>使用CSS Modules</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  // …</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.css$/,</span><br><span class="line">        use: [</span><br><span class="line">          &apos;style-loader&apos;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &apos;css-loader&apos;,</span><br><span class="line">            options:</span><br><span class="line">              &#123;</span><br><span class="line">                modules: true</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      // …</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>配置React，推荐使用<a href="https://github.com/gajus/react-css-modules" target="_blank" rel="noopener">react-css-modules</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install react-css-modules --save-dev</span><br></pre></td></tr></table></figure></p><h5 id="autoprefixer"><a href="#autoprefixer" class="headerlink" title="autoprefixer"></a>autoprefixer</h5><p>有些样式不同浏览器需要加不同的前缀，如-webkit-，使用autoprefixer会自动帮我们加上这些前缀。<br>autoprefixer-loader已经废弃不再维护了，推荐使用<a href="https://github.com/postcss/postcss-loader" target="_blank" rel="noopener">postcss-loader</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">npm install postcss-loader autoprefixer --save-dev</span><br><span class="line"></span><br><span class="line">// webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // …</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.css$/,</span><br><span class="line">        use: [</span><br><span class="line">          &apos;style-loader&apos;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &apos;css-loader&apos;,</span><br><span class="line">            options:</span><br><span class="line">              &#123;</span><br><span class="line">                modules: true,</span><br><span class="line">                importLoaders: 1</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &apos;postcss-loader&apos;</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      // …</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>然后配置postcss，根目录下新建配置文件postcss.config.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">      require(&apos;autoprefixer&apos;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="使用Sass"><a href="#使用Sass" class="headerlink" title="使用Sass"></a>使用Sass</h5><p>sass-loader依赖node-sass<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">npm install sass-loader node-sass  --save-dev</span><br><span class="line"></span><br><span class="line">// webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // …</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(sass|scss)$/,</span><br><span class="line">        use: [</span><br><span class="line">          &quot;style-loader&quot;,</span><br><span class="line">          &quot;css-loader&quot;,</span><br><span class="line">          &quot;postcss-loader&quot;,</span><br><span class="line">          &quot;sass-loader&quot;,</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">      // …</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h3><h4 id="ExtractTextWebpackPlugin"><a href="#ExtractTextWebpackPlugin" class="headerlink" title="ExtractTextWebpackPlugin"></a>ExtractTextWebpackPlugin</h4><p>上面我们讲了webpack中style的处理，但是我们有些时候我们希望将样式抽取成独立的文件。这里我们使用 webpack 插件<a href="https://webpack.js.org/plugins/extract-text-webpack-plugin/" target="_blank" rel="noopener">ExtractTextWebpackPlugin</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev extract-text-webpack-plugin</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  //...</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.scss/,</span><br><span class="line">        use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">          fallback: &apos;style-loader&apos;,</span><br><span class="line">          use: [</span><br><span class="line">            &#123;</span><br><span class="line">              loader: &apos;css-loader&apos;,</span><br><span class="line">              options: &#123;</span><br><span class="line">                modules: true,</span><br><span class="line">                importLoaders: 2,</span><br><span class="line">                localIdentName: &apos;[folder]__[local]__[hash:base64:5]&apos;,</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              loader: &apos;postcss-loader&apos;</span><br><span class="line">            &#125;</span><br><span class="line">            &#123;</span><br><span class="line">              loader: &apos;sass-loader&apos;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  //...</span><br><span class="line">  plugins: [</span><br><span class="line">    new ExtractTextPlugin(&#123;</span><br><span class="line">      filename: &apos;style.css&apos;,</span><br><span class="line">      allChunks: false</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 output 指定的目录中会有一个 style.css 文件. 最后, 在 HTML 文件中通过 <link> 标签正常引用.</p><h4 id="代码压缩"><a href="#代码压缩" class="headerlink" title="代码压缩"></a>代码压缩</h4><p>使用 <a href="https://webpack.js.org/plugins/uglifyjs-webpack-plugin/#components/sidebar/sidebar.jsx" target="_blank" rel="noopener">UglifyjsWebpackPlugin</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const UglifyJSPlugin = require(&apos;uglifyjs-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // ...</span><br><span class="line">  plugins: [</span><br><span class="line">    new UglifyJSPlugin(&#123;</span><br><span class="line">      compress: &#123;</span><br><span class="line">        warnings: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="HTML模板"><a href="#HTML模板" class="headerlink" title="HTML模板"></a>HTML模板</h4><p><a href="https://webpack.js.org/plugins/html-webpack-plugin/#components/sidebar/sidebar.jsx" target="_blank" rel="noopener">HtmlWebpackPlugin</a><br>使用这个插件，我们可以自定义HTML模板，自动生成相应的HTML文件，包括自动插入webpack生成的css和js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">npm install html-webpack-plugin --save-dev</span><br><span class="line"></span><br><span class="line">// webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // ...</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: &apos;Hello App&apos;,</span><br><span class="line">      template: path.resolve(__dirname, &apos;src/templates/index.html&apos;),</span><br><span class="line">      filename: &apos;index.html&apos;,</span><br><span class="line">      //chunks这个参数告诉插件要引用entry里面的哪几个入口</span><br><span class="line">      chunks: [&apos;app&apos;],</span><br><span class="line">      //要把script插入到标签里</span><br><span class="line">      inject: &apos;body&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="配置webpack-dev-server"><a href="#配置webpack-dev-server" class="headerlink" title="配置webpack-dev-server"></a>配置webpack-dev-server</h3><p><a href="https://webpack.js.org/configuration/dev-server/#components/sidebar/sidebar.jsx" target="_blank" rel="noopener">webpack-dev-server</a><br>开发环境下搭建开发服务器，可以在开发的时候实时更新页面，方便开发和调试。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-dev-server --save-dev</span><br><span class="line"></span><br><span class="line">//webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  ....</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    historyApiFallback: true,</span><br><span class="line">    hot: true</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Devtool"><a href="#Devtool" class="headerlink" title="Devtool"></a>Devtool</h3><p>webpack提供了souce map来提高debug的效率<br>在配置文件中直接配置devtool属性，就可以开始source map<br>支持的的类型<br><img src="/images/sourcemap.png" alt="images"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devtool: eval-source-map</span><br></pre></td></tr></table></figure></p><h3 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h3><p>resolve属性可以配置extensions和alias</p><ul><li>extensions可以配置自动完成的文件后缀，例如：我们在写index.jsx的时候就可以简写成index</li><li>alias 可以配置一些目录的别名，方便我们引入，也可以加快webpack打包时索引速度。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  extensions: [&apos;.js&apos;, &apos;.jsx&apos;],</span><br><span class="line">  alias: &#123;</span><br><span class="line">    components: path.resolve(__dirname, &apos;src/components&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="npm-script配置"><a href="#npm-script配置" class="headerlink" title="npm script配置"></a>npm script配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;start&quot;: &quot;webpack-dev-server --devtool eval-source-map --progress  --colors --hot&quot;,</span><br><span class="line">  &quot;build&quot;: &quot;webpack -p --progress --colors&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些命令的解释：</p><ul><li>–colors 输出的结果带彩色</li><li>–progress 输出进度显示</li><li>–watch 动态实时监测依赖文件变化并且更新</li><li>–hot 是热插拔</li><li>–display-error-details 错误的时候显示更多详细错误信息</li><li>-w 动态实时监测依赖文件变化并且更新</li><li>-d 提供sorcemap</li><li>-p 对打包文件进行压缩</li></ul><p>配置之后，开发环境直接执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run start</span><br></pre></td></tr></table></figure></p><p>打包则执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack</a><br><a href="https://github.com/dwqs/blog/issues/46" target="_blank" rel="noopener">[译]Webpack 2 快速入门</a><br><a href="https://babeljs.io/" target="_blank" rel="noopener">Babel</a></p></blockquote><h2 id="配置Demo源码"><a href="#配置Demo源码" class="headerlink" title="配置Demo源码"></a>配置Demo源码</h2><p><a href="https://github.com/hhking/webpack-guides" target="_blank" rel="noopener">github</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  &lt;img src=&quot;/images/webpack.png&quot; alt=&quot;images&quot;&gt;&lt;br&gt;&lt;em&gt;webpack 已经更新到2.2版本。webpack v1 官方已经不推荐使用,建议更新到webpack 2。 (2017-03-12)&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;四大核心概念-Four-Core-Concepts&quot;&gt;&lt;a href=&quot;#四大核心概念-Four-Core-Concepts&quot; class=&quot;headerlink&quot; title=&quot;四大核心概念 (Four Core Concepts)&quot;&gt;&lt;/a&gt;四大核心概念 (Four Core Concepts)&lt;/h2&gt;&lt;p&gt;webpack 是现代JavaScript应用的模块打包工具（module bundler），具有高度可配置性。&lt;br&gt;在开始配置webpack之前，我们需要先理解它的四大核心概念，有助于我们理解webpack的工具方式。&lt;/p&gt;
    
    </summary>
    
      <category term="关于前端" scheme="https://blog.hhking.cn/categories/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="webpack" scheme="https://blog.hhking.cn/tags/webpack/"/>
    
      <category term="react" scheme="https://blog.hhking.cn/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>移动端重构笔记</title>
    <link href="https://blog.hhking.cn/2017/03/04/mobile-refactoring-mark/"/>
    <id>https://blog.hhking.cn/2017/03/04/mobile-refactoring-mark/</id>
    <published>2017-03-04T08:24:27.000Z</published>
    <updated>2018-08-17T07:06:58.128Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-box-sizing-设置"><a href="#1-box-sizing-设置" class="headerlink" title="1. box-sizing 设置"></a>1. box-sizing 设置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">box-sizing: content-box|border-box</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li><p><strong>content-box</strong><br>默认值，标准和模型。width与height只包括内容的宽和高，不包括边框(border)，内边距(padding)，外边距(margin)。也就是说，内边距、边框和外边距都在盒子的外部。</p><p>尺寸计算公式：<br>width = 内容的宽度<br>height = 内容的高度<br><em>宽度和高度都不包含内容的边框 （border）和内边距（padding）</em></p></li><li><p><strong>border-box</strong><br>width和height包括了内边距(padding)和边框(border)，不包括外边距(margin)。这时候外边距和边框是包含在盒子中。</p><p>尺寸计算公式：<br>width = border + padding + 内容的宽度<br>height = border + padding + 内容的高度</p><p>所以如果将一个元素width设置100%，同时又设置边框或者左右padding时，元素的尺寸会大于100%，也会出现水平方向的滚动条。这时候可以设置border-box就可以解决这个问题。</p></li></ul><h4 id="2-字体设置"><a href="#2-字体设置" class="headerlink" title="2. 字体设置"></a>2. 字体设置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    font-family: -apple-system, BlinkMacSystemFont, &quot;PingFang SC&quot;,&quot;Helvetica Neue&quot;,STHeiti,&quot;Microsoft Yahei&quot;,Tahoma,Simsun,sans-serif;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>详情参考<a href="https://github.com/AlloyTeam/Mars/blob/master/solutions/font-family.md" target="_blank" rel="noopener">font-family</a></p></blockquote><h4 id="3-webkit-overflow-scrolling"><a href="#3-webkit-overflow-scrolling" class="headerlink" title="3. -webkit-overflow-scrolling"></a>3. -webkit-overflow-scrolling</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-webkit-overflow-scrolling: touch;/* 当手指从触摸屏上移开，会保持一段时间的滚动 */</span><br><span class="line">-webkit-overflow-scrolling: auto;/* 当手指从触摸屏上移开，滚动会立即停止 */</span><br></pre></td></tr></table></figure><p>一般为了更好的体验，都会将该属性设置为touch<br><em>该属性仅支持：移动版 Safari  iOS 5.0+</em></p><h4 id="4-webkit-tap-highlight-color"><a href="#4-webkit-tap-highlight-color" class="headerlink" title="4. -webkit-tap-highlight-color"></a>4. -webkit-tap-highlight-color</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-webkit-tap-highlight-color: transparent;</span><br></pre></td></tr></table></figure><p>去除a标签点击时的高亮效果（对于ios点击元素的时候，就会出现一个半透明的灰色背景；对于android则出现红色的边框）</p><h4 id="5-webkit-text-size-adjust"><a href="#5-webkit-text-size-adjust" class="headerlink" title="5. -webkit-text-size-adjust"></a>5. -webkit-text-size-adjust</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-webkit-text-size-adjust: 100%;</span><br><span class="line">text-size-adjust: 100%;</span><br></pre></td></tr></table></figure><p>浏览器纵向 (Portrate mode) 和橫向 (Landscape mode) 模式皆有自动调整字体大小的功能。控制它的就是 CSS 中的 -webkit-text-size-adjust</p><h4 id="6-webkit-appearance"><a href="#6-webkit-appearance" class="headerlink" title="6. -webkit-appearance"></a>6. -webkit-appearance</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-webkit-appearance:none;</span><br></pre></td></tr></table></figure><p>iOS设备上，使用input时会有内阴影，这是因为-webkit-appearance默认样式的原因，可以覆盖该属性来取出input的内阴影。</p><h4 id="7-postion-sticky"><a href="#7-postion-sticky" class="headerlink" title="7. postion: sticky"></a>7. postion: sticky</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">position: -webkit-sticky</span><br><span class="line">position: sticky;</span><br></pre></td></tr></table></figure><p>粘性定位元素，在iOS上做粘性导航（例如页面滚动某个位置时，将导航固定在顶部）的时候效果很好。安卓上不支持该属性，只能通过scroll事件配合fixed定位要模拟实现。</p><p>postion: sticky元素先按照普通文档流定位，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。在所有情况下（即便被定位元素为 table 时），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。position: sticky 对 table 元素的效果与 position: relative 相同。</p><h4 id="8-meta"><a href="#8-meta" class="headerlink" title="8. meta"></a>8. meta</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--忽略页面中的数字识别为电话号码、email识别--&gt;</span><br><span class="line">&lt;meta name=&quot;format-detection&quot; content=&quot;telphone=no, email=no&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 启用360浏览器的极速模式(webkit) --&gt;</span><br><span class="line">&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 优先使用 IE 最新版本和 Chrome --&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;</span><br><span class="line">&lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 微软的老式浏览器 --&gt;</span><br><span class="line">&lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- uc强制竖屏 --&gt;</span><br><span class="line">&lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- QQ强制竖屏 --&gt;</span><br><span class="line">&lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- UC强制全屏 --&gt;</span><br><span class="line">&lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- QQ强制全屏 --&gt;</span><br><span class="line">&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- UC应用模式 --&gt;</span><br><span class="line">&lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- QQ应用模式 --&gt;</span><br><span class="line">&lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- windows phone 点击无高光 --&gt;</span><br><span class="line">&lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt;</span><br></pre></td></tr></table></figure><h4 id="9-viewport"><a href="#9-viewport" class="headerlink" title="9.viewport"></a>9.viewport</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1.0,width=device-width,user-scalable=0,maximum-scale=1.0&quot;/&gt;</span><br></pre></td></tr></table></figure><blockquote><p>参考<br><a href="http://www.quirksmode.org/mobile/viewports.html" target="_blank" rel="noopener">ppk 谈 viewport其1</a><br><a href="http://www.quirksmode.org/mobile/viewports2.html" target="_blank" rel="noopener">ppk 谈 viewport其2</a><br><a href="http://www.quirksmode.org/mobile/metaviewport/" target="_blank" rel="noopener">ppk 谈 viewport其3</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-box-sizing-设置&quot;&gt;&lt;a href=&quot;#1-box-sizing-设置&quot; class=&quot;headerlink&quot; title=&quot;1. box-sizing 设置&quot;&gt;&lt;/a&gt;1. box-sizing 设置&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;box-sizing: content-box|border-box&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="关于前端" scheme="https://blog.hhking.cn/categories/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="移动端" scheme="https://blog.hhking.cn/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
      <category term="重构" scheme="https://blog.hhking.cn/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>React开发技术栈</title>
    <link href="https://blog.hhking.cn/2017/02/26/react-technology-stack/"/>
    <id>https://blog.hhking.cn/2017/02/26/react-technology-stack/</id>
    <published>2017-02-26T12:26:12.000Z</published>
    <updated>2018-08-17T07:06:49.587Z</updated>
    
    <content type="html"><![CDATA[<p>　　在之前的项目中，使用React进行开发，这里简单介绍一下搭建React开发环境和开发过程中所用到的技术和工具，从全局去浏览一下React全家桶，也算是一个总结和记录。</p><a id="more"></a><h3 id="项目解决方案"><a href="#项目解决方案" class="headerlink" title="项目解决方案"></a>项目解决方案</h3><ul><li>多页 + Ajax + 前端框架(React) + (模块化)依赖管理(webpack/ES2015) + 状态管理(Redux)</li></ul><h3 id="工具列表"><a href="#工具列表" class="headerlink" title="工具列表"></a>工具列表</h3><ul><li>Node环境</li><li>构建工具webpack</li><li>ES6语法</li><li>ES6编译工具Babel</li><li>框架React</li><li>状态管理Redux</li><li>Ajax请求库superagent</li></ul><h3 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h3><ul><li>使用Airbnb的React编码规范，实际使用中根据实际情况调整<br><a href="https://github.com/hhking/javascript/tree/master/react" target="_blank" rel="noopener">Airbnb React/JSX Style  Guide</a></li></ul><h3 id="Node-amp-npm"><a href="#Node-amp-npm" class="headerlink" title="Node &amp; npm"></a>Node &amp; npm</h3><p>　　首先要安装Node.js，这是整个工程的一个运行环境。<br>　　Node中的path模块在项目的配置中比较常用，这里列举比较常用的方法。</p><h4 id="Node-path模块"><a href="#Node-path模块" class="headerlink" title="Node path模块"></a>Node path模块</h4>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 首先需要引入path --&gt;</span><br><span class="line">var path = require(&apos;path&apos;);</span><br></pre></td></tr></table></figure><ul><li><p>path.join()</p><p>path.join方法用于连接路径。该方法会正确使用当前系统的路径分隔符，Unix系统是”/“，Windows系统是”\“，可以解决不同平台的兼容问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.join(mydir, &quot;src&quot;);</span><br></pre></td></tr></table></figure></li><li><p>path.resolve()</p><p>path.resolve() 将相对路径转为绝对路径</p><p>它可以接受多个参数，依次表示所要进入的路径，直到将最后一个参数转为绝对路径。如果根据参数无法得到绝对路径，就以当前所在路径作为基准。除了根目录，该方法的返回值都不带尾部的斜杠。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">path.resolve(&apos;/foo/bar&apos;, &apos;./baz&apos;)</span><br><span class="line">// &apos;/foo/bar/baz&apos;Â</span><br><span class="line"></span><br><span class="line">path.resolve(&apos;/foo/bar&apos;, &apos;/tmp/file/&apos;)</span><br><span class="line">// &apos;/tmp/file&apos;</span><br><span class="line"></span><br><span class="line">path.resolve(&apos;wwwroot&apos;, &apos;static_files/png/&apos;, &apos;../gif/image.gif&apos;)</span><br><span class="line">// 如果当前目录是/home/myself/node，返回</span><br><span class="line">// /home/myself/node/wwwroot/static_files/gif/image.gif</span><br></pre></td></tr></table></figure><p>详细可以看<a href="https://javascript.ruanyifeng.com/nodejs/path.html" target="_blank" rel="noopener">阮一峰讲的Path模块</a></p><h4 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h4><p>　　npm是Node的模块管理器，功能极其强大</p></li><li><p>常用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 自动安装package.json里保存的模块 --&gt;</span><br><span class="line">npm install</span><br><span class="line">&lt;!-- 安装指定的模块 --&gt;</span><br><span class="line">npm install --save-dev &lt;packageName&gt;</span><br></pre></td></tr></table></figure></li><li><p>配置文件： package.json<br>保存了Node.js的配置，可以手动创建，也可以通过npm init命令来进行配置</p></li></ul><h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><p>  　　webpack是前端资源加载/打包工具，目的就是把有依赖关系的各种文件打包成一系列的静态资源。<br>  <img src="/images/what-is-webpack.png" alt="imgage"></p><p>  业界通用的方案是直接用npm scripts来定义项目内置脚本</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//example</span><br><span class="line">//--profile输出性能数据，可以看到每一步的耗时</span><br><span class="line">//--colors 输出结果带彩色，比如：会用红色显示耗时较长的步骤</span><br><span class="line">//--hot 模块热替换</span><br><span class="line">&quot;start&quot;: &quot;cross-env NODE_ENV=development webpack-dev-server --progress  --profile --colors --hot --content-base ../../../&quot;</span><br><span class="line"></span><br><span class="line">npm run start</span><br></pre></td></tr></table></figure>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 安装webpack --&gt;</span><br><span class="line">npm install -g webpack</span><br><span class="line">&lt;!-- webpack配套的web服务器webpack-dev-server --&gt;</span><br><span class="line">npm install --save-dev webpack-dev-server</span><br></pre></td></tr></table></figure><h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><p>　　React把用户界面抽象成一个组件，例如按钮组件Button、对话框组件Dialog、日期组件Calendar，一个完整的页面就是开发者通过组合这些组件，最终得到的功能丰富、可交互的页面。由于有了组件这层抽象，整个结构更加清晰，复用也更加容易。</p><p><img src="/images/component_example.png" alt="image"></p><p>React具有以下特点</p><ul><li>专注视图层</li><li>Virtual DOM</li><li>函数式编程</li></ul><h3 id="ECMAScript-6"><a href="#ECMAScript-6" class="headerlink" title="ECMAScript 6"></a>ECMAScript 6</h3><p>　　ES6十大特性</p><ul><li>Default Parameters（默认参数） in ES6</li><li>Template Literals （模板文本）in ES6</li><li>Multi-line Strings （多行字符串）in ES6</li><li>Destructuring Assignment （解构赋值）in ES6</li><li>Enhanced Object Literals （增强的对象文本）in ES6</li><li>Arrow Functions （箭头函数）in ES6</li><li>Promises in ES6</li><li>Block-Scoped Constructs Let and Const（块作用域构造Let and Const）</li><li>Classes（类） in ES6</li><li>Modules（模块） in ES6</li></ul><p>　　使用ES6语法，可以使用新的语法的特性，减少大量冗余的代码，提高编码的效率，同时也能提高程序的健壮性。</p><p>可以通过下面这本书来学习ES6<br><a href="https://es6.ruanyifeng.com/" target="_blank" rel="noopener">ECMAScript 6 入门</a>:阮一峰的一本开源的 JavaScript 语言教程，全面介绍 ECMAScript 6 新引入的语法特性。</p><h3 id="ES6编译工具：Babel"><a href="#ES6编译工具：Babel" class="headerlink" title="ES6编译工具：Babel"></a>ES6编译工具：Babel</h3><p>　　怎么使用ES6？使用ES6编译工具Babel，将将ES6代码转为ES5代码，从而在现有环境执行。当然，也有一些方法特性在一些低级浏览器还不支持，我们可以加入Babel的polyfill来支持。<br>　　Babel的配置文件是.babelrc，用来设置转码规则和插件。</p><h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><p>　　Redux是Flux架构的的优化和扩展<br>在复杂应用中和React结合使用，管理React的数据状态，让React专注于视图层<br>但是对于简单的UI层，Redux就不是必要的，用了反而增加复杂性</p><h3 id="CSS-Modules"><a href="#CSS-Modules" class="headerlink" title="CSS Modules"></a>CSS Modules</h3><ul><li>样式局部化，解决命名冲突和全局污染问题</li><li>class名的生成规则配置灵活</li><li>组件化，一个组件的JavaScript里就包含了组件所依赖的CSS</li></ul><p>　　配合React，我们可以使用简化CSSModules的库<a href="https://github.com/gajus/react-css-modules" target="_blank" rel="noopener">react-css-modules</a></p><h3 id="Ajax请求库"><a href="#Ajax请求库" class="headerlink" title="Ajax请求库"></a>Ajax请求库</h3><ul><li><p><a href="https://github.com/visionmedia/superagent" target="_blank" rel="noopener">superagent</a><br>Node.js里一个方便的请求代理模块，我们用它来实现我们的Ajax请求</p></li><li><p><a href="https://github.com/ded/reqwest" target="_blank" rel="noopener">reqwest</a></p></li><li><p><a href="https://github.com/mzabriskie/axios" target="_blank" rel="noopener">axios</a><br>支持Promise</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch" target="_blank" rel="noopener">fetch</a><br>需要配合<a href="https://github.com/github/fetch" target="_blank" rel="noopener">fetch polyfill</a><br>缺少进度progress，中断abort等一些方法</p></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>提升React性能的<a href="https://github.com/facebook/immutable-js/" target="_blank" rel="noopener">Immutable</a>库，以及配套的PureRender库(react-immutable-render-mixin)(<a href="https://github.com/jurassix/react-immutable-render-mixin" target="_blank" rel="noopener">https://github.com/jurassix/react-immutable-render-mixin</a>)</li><li>动画库<a href="https://github.com/chenglou/react-motion" target="_blank" rel="noopener">React Motion</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　在之前的项目中，使用React进行开发，这里简单介绍一下搭建React开发环境和开发过程中所用到的技术和工具，从全局去浏览一下React全家桶，也算是一个总结和记录。&lt;/p&gt;
    
    </summary>
    
      <category term="关于前端" scheme="https://blog.hhking.cn/categories/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="React" scheme="https://blog.hhking.cn/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>npm install慢或者无响应解决方案</title>
    <link href="https://blog.hhking.cn/2017/02/19/npm-install/"/>
    <id>https://blog.hhking.cn/2017/02/19/npm-install/</id>
    <published>2017-02-19T08:41:34.000Z</published>
    <updated>2018-08-17T07:06:46.029Z</updated>
    
    <content type="html"><![CDATA[<p>npm默认是国外的源：<a href="http://registry.npmjs.org，" target="_blank" rel="noopener">http://registry.npmjs.org，</a><br>所以在国内会遇到npm install安装包的时候速度很慢，甚至无响应，<br>所以我们需要把npm切换成国内镜像源，为包的安装加速。</p><a id="more"></a><blockquote><p>这里参考网上的一些解决方案，记录一下自己用的方法</p></blockquote><h3 id="npm切换到淘宝npm镜像方法"><a href="#npm切换到淘宝npm镜像方法" class="headerlink" title="npm切换到淘宝npm镜像方法"></a>npm切换到淘宝npm镜像方法</h3><h4 id="临时切换方案"><a href="#临时切换方案" class="headerlink" title="临时切换方案"></a>临时切换方案</h4><ul><li><p>通过命令行指定</p><pre><code>npm --registry https://registry.npm.taobao.org info underscore</code></pre><p>（如果上面配置正确这个命令会有字符串response，下次使用时需要重新设置）</p></li></ul><h4 id="永久切换"><a href="#永久切换" class="headerlink" title="永久切换"></a>永久切换</h4><pre><code>有下面两种方法，下次使用时不需要重新设置</code></pre><ul><li><p>通过config命令</p><pre><code>npm config set registry https://registry.npm.taobao.orgnpm info underscore</code></pre><p>（如果上面配置正确这个命令会有字符串response）</p></li></ul><ul><li><p>编辑 ~/.npmrc 加入下面内容</p><pre><code>registry = https://registry.npm.taobao.org</code></pre></li></ul><h3 id="使用nrm切换"><a href="#使用nrm切换" class="headerlink" title="使用nrm切换"></a>使用nrm切换</h3><p>nrm是一个npm源管理器，可以让我们快速的切换不同的npm源</p><h4 id="nrm安装"><a href="#nrm安装" class="headerlink" title="nrm安装"></a>nrm安装</h4><pre><code>npm install -g nrm</code></pre><h4 id="列出所有源"><a href="#列出所有源" class="headerlink" title="列出所有源"></a>列出所有源</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  nrm ls</span><br><span class="line"></span><br><span class="line">  npm ---- https://registry.npmjs.org/</span><br><span class="line">  cnpm --- http://r.cnpmjs.org/</span><br><span class="line">* taobao - https://registry.npm.taobao.org/</span><br><span class="line">  nj ----- https://registry.nodejitsu.com/</span><br><span class="line">  rednpm - http://registry.mirror.cqupt.edu.cn/</span><br><span class="line">  npmMirror  https://skimdb.npmjs.com/registry/</span><br><span class="line">  edunpm - http://registry.enpmjs.org/</span><br></pre></td></tr></table></figure><h4 id="切换源"><a href="#切换源" class="headerlink" title="切换源"></a>切换源</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nrm use npm</span><br><span class="line"></span><br><span class="line">   Registry has been set to: https://registry.npmjs.org/</span><br></pre></td></tr></table></figure><h4 id="使用命令"><a href="#使用命令" class="headerlink" title="使用命令"></a>使用命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Usage: nrm [options] [command]</span><br><span class="line"></span><br><span class="line">  Commands:</span><br><span class="line"></span><br><span class="line">    ls                           List all the registries</span><br><span class="line">    use                Change registry to registry</span><br><span class="line">    add   [home]  Add one custom registry</span><br><span class="line">    del                Delete one custom registry</span><br><span class="line">    home  [browser]    Open the homepage of registry with optional browser</span><br><span class="line">    test [registry]              Show the response time for one or all registries</span><br><span class="line">    help                         Print this help</span><br><span class="line"></span><br><span class="line">  Options:</span><br><span class="line"></span><br><span class="line">    -h, --help     output usage information</span><br><span class="line">    -V, --version  output the version number</span><br></pre></td></tr></table></figure><blockquote><p>  注:切换到其他npm之后，publish会无效，npm publish时要记得切回去</p></blockquote><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote><p><a href="https://npm.taobao.org/" target="_blank" rel="noopener">https://npm.taobao.org/</a><br><a href="https://segmentfault.com/a/1190000002642514" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002642514</a><br><a href="https://github.com/Pana/nrm" target="_blank" rel="noopener">https://github.com/Pana/nrm</a><br><a href="http://www.uedbox.com/npm-install-slow-solution/" target="_blank" rel="noopener">http://www.uedbox.com/npm-install-slow-solution/</a> （三种解决方案）</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;npm默认是国外的源：&lt;a href=&quot;http://registry.npmjs.org，&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://registry.npmjs.org，&lt;/a&gt;&lt;br&gt;所以在国内会遇到npm install安装包的时候速度很慢，甚至无响应，&lt;br&gt;所以我们需要把npm切换成国内镜像源，为包的安装加速。&lt;/p&gt;
    
    </summary>
    
      <category term="关于前端" scheme="https://blog.hhking.cn/categories/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Node" scheme="https://blog.hhking.cn/tags/Node/"/>
    
      <category term="npm" scheme="https://blog.hhking.cn/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>jQuery实现输入框标签的自动添加和删除等操作</title>
    <link href="https://blog.hhking.cn/2015/03/26/my-new-post20150326/"/>
    <id>https://blog.hhking.cn/2015/03/26/my-new-post20150326/</id>
    <published>2015-03-26T04:51:44.000Z</published>
    <updated>2018-07-27T10:31:07.652Z</updated>
    
    <content type="html"><![CDATA[<p><strong>记录一下这两天写的。</strong></p><hr><h3 id="实现如下对待选标签的操作"><a href="#实现如下对待选标签的操作" class="headerlink" title="实现如下对待选标签的操作"></a>实现如下对待选标签的操作</h3><blockquote><ul><li>点击待选标签列表中的标签，标签从原来的位置消失，出现在输入框中</li><li>点击标签上的X图标或者按退格键删除已选的标签，被删除的标签会回到原来待选标签的位置</li><li>输入框可以输入标签文字后按回车键、空格键或者输入框失去焦点时自动生成标签</li></ul></blockquote><a id="more"></a><hr><h3 id="截图展示"><a href="#截图展示" class="headerlink" title="截图展示"></a>截图展示</h3><ul><li><p>部分效果图1：<br><img src="http://7xi86v.com1.z0.glb.clouddn.com/tags1.jpg" alt="效果图1"></p></li><li><p>部分效果图1：<br><img src="http://7xi86v.com1.z0.glb.clouddn.com/tags2.jpg" alt="效果图2"></p></li></ul><hr><h3 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h3><h4 id="界面方面"><a href="#界面方面" class="headerlink" title="界面方面"></a>界面方面</h4><blockquote><ul><li>首先要注意到，看上去输入框中出现的标签，实际上并不是在输入框中，而是在input之前通过添加span（标签）来实现，也就是说添加的标签事实上是在input之外的；</li><li>通过外围的div包住input和span，设置边框，去掉input原来的表框，便造成视觉上的input的边框，添加的标签也出现在这个边框里；</li></ul></blockquote><p>如下代码：</p><ul><li><p>html:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"label_in"</span>&gt;</span><br><span class="line">            &lt;p&gt;产品类别&lt;b&gt;*&lt;/b&gt;:&lt;/p&gt;</span><br><span class="line">            &lt;div class=<span class="string">"area"</span>&gt;</span><br><span class="line">                &lt;div class=<span class="string">"add"</span>&gt;</span><br><span class="line">                    &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"input"</span> placeholder=<span class="string">"输入标签..."</span> /&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">                &lt;br class=<span class="string">"clear"</span> /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>css:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.area&#123;</span><br><span class="line">    width: 960px;</span><br><span class="line">    border: 1px solid <span class="comment">#a09d9d;</span></span><br><span class="line">&#125;</span><br><span class="line">.add &#123;</span><br><span class="line">    <span class="built_in">float</span>: left;</span><br><span class="line">    line-height: 28px;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    border: none;</span><br><span class="line">&#125;</span><br><span class="line">input &#123;</span><br><span class="line">    <span class="built_in">float</span>: left;</span><br><span class="line">    height: 28px;</span><br><span class="line">    margin: 5px 0;</span><br><span class="line">    padding-left: 12px;</span><br><span class="line">    line-height: 28px;</span><br><span class="line">    font-size: 18px;</span><br><span class="line">    border: none;</span><br><span class="line">    outline: none;</span><br><span class="line">&#125;</span><br><span class="line">.clear&#123;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="jQuery实现功能方面"><a href="#jQuery实现功能方面" class="headerlink" title="jQuery实现功能方面"></a>jQuery实现功能方面</h4><blockquote><ul><li>标签点击事件。对整个标签列表进行绑定点击事件，注意要判断点击到span时候执行，否则点到margin（空白处）会将整个父节点作为目标。点击标签时，先复制clone()点击的span，在插入insertBefore()到input之前，并添加X图标；然后将原来的hide()（理论上也可以删除）。这里的num是原来在span标签里的排序位置，即index值，作为input之前标签的id，用于后面删除时，定位要显示的span，这个样就可以将标签恢复到原来位置。</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//点击事件，点击标签选择，标签出现在输入框，原来位置隐藏</span><br><span class="line">        $(<span class="string">".label_type"</span>).click(<span class="keyword">function</span> (e) &#123;</span><br><span class="line">            var num = $(e.target).index();</span><br><span class="line">            var a = $(e.target).attr(<span class="string">'class'</span>);</span><br><span class="line">            //判断点的不是空白地方（标签的父标签）</span><br><span class="line">            <span class="keyword">if</span> (a != <span class="string">"label_type"</span>) &#123;</span><br><span class="line">                $(e.target).<span class="built_in">clone</span>().insertBefore($(<span class="string">".add input"</span>)).addClass(<span class="string">"ad"</span>).attr(<span class="string">'id'</span>, num).append(<span class="string">"&lt;b class='close'&gt;ⓧ&lt;/b&gt;"</span>);</span><br><span class="line">                $(e.target).hide();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><blockquote><ul><li>X图标点击事件。将点击的那个span删除，在通过id定位原来的位置，将其show()显示出来。</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//点击事件，点击X号时候删除标签，并在原来位置显示</span><br><span class="line">        $(<span class="string">".add"</span>).click(<span class="keyword">function</span> (e) &#123;</span><br><span class="line">            <span class="keyword">if</span> ($(e.target).html() == <span class="string">"ⓧ"</span>) &#123;</span><br><span class="line">                var numid = $(e.target).closest(<span class="string">"span"</span>).attr(<span class="string">'id'</span>);</span><br><span class="line">                $(e.target).closest(<span class="string">"span"</span>).remove();</span><br><span class="line">                $(<span class="string">".label_type span"</span>).eq(numid).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><blockquote><ul><li>退格键的keyCode==8，执行删除操作。获取input之前的那个元素，并将其删除，同时通过id恢复原来的标签。这里要注意输入框中为空是执行，当输入框中有内容时正常删除操作。</li><li>回车、空格以及输入框失去焦点都执行同一个操作。这里调用autocomplete()函数执行操作。</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//按键事件</span><br><span class="line">        $(document).keydown(<span class="keyword">function</span> (e) &#123;</span><br><span class="line">            //获取输入框里的内容</span><br><span class="line">            var content = $(<span class="string">"input"</span>).val();</span><br><span class="line">            //按下退格键时触发时间</span><br><span class="line">            <span class="keyword">if</span> (e.keyCode == 8) &#123;</span><br><span class="line">                //判断输入框里是否为空，为空时退格键触发删除标签</span><br><span class="line">                <span class="keyword">if</span> (content == <span class="string">""</span>) &#123;</span><br><span class="line">                    //获取里输入框最近一个标签的id，然后删除，并通过id定位到便签原来的位置并显示出来</span><br><span class="line">                    var numid = $(<span class="string">".add input"</span>).prev().attr(<span class="string">'id'</span>);</span><br><span class="line">                    $(<span class="string">".add input"</span>).prev().remove();</span><br><span class="line">                    $(<span class="string">".label_type span"</span>).eq(numid).show();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.keyCode == 13 || e.keyCode == 32) &#123; //回车键和空格键事件</span><br><span class="line">                //调用函数</span><br><span class="line">                autocomplete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        //输入框失去焦点时进行匹配生成标签</span><br><span class="line">        $(<span class="string">"input"</span>).blur(autocomplete);</span><br></pre></td></tr></table></figure><blockquote><ul><li>autocomplete()函数如下。这里对输入的标签通过for循环一个一个与标签列表进行匹配</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//遍历匹配生成对应标签</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">autocomplete</span></span>() &#123;</span><br><span class="line">    var content = $(<span class="string">"input"</span>).val();</span><br><span class="line">    //获取标签的总个数，用于遍历</span><br><span class="line">    var len = $(<span class="string">".label_type"</span>).children().length;</span><br><span class="line">    //遍历标签，判断输入的是否存在于标签了</span><br><span class="line">    <span class="keyword">for</span> (var i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        var con = $(<span class="string">".label_type span"</span>).eq(i).text();</span><br><span class="line">        //这里判断输入框里是否为空，并且进行匹配，输入只需要匹配到部分，方便输入</span><br><span class="line">        <span class="keyword">if</span> (content != <span class="string">""</span> &amp;&amp; con.match(content)) &#123;</span><br><span class="line">            $(<span class="string">".label_type span"</span>).eq(i).<span class="built_in">clone</span>().insertBefore($(<span class="string">".add input"</span>)).addClass(<span class="string">"ad"</span>).attr(<span class="string">'id'</span>, i).append(<span class="string">"&lt;b class='close'&gt;ⓧ&lt;/b&gt;"</span>);</span><br><span class="line">            $(<span class="string">".label_type span"</span>).eq(i).hide();</span><br><span class="line">            $(<span class="string">"input"</span>).val(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Demo和源码"><a href="#Demo和源码" class="headerlink" title="Demo和源码"></a>Demo和源码</h3><p><a href="http://calltesting.sinaapp.com/tags/tags.html" target="_blank" rel="noopener">效果展示：Demo</a><br><a href="https://github.com/hhking/Label_operation" target="_blank" rel="noopener">源代码地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;记录一下这两天写的。&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;实现如下对待选标签的操作&quot;&gt;&lt;a href=&quot;#实现如下对待选标签的操作&quot; class=&quot;headerlink&quot; title=&quot;实现如下对待选标签的操作&quot;&gt;&lt;/a&gt;实现如下对待选标签的操作&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;点击待选标签列表中的标签，标签从原来的位置消失，出现在输入框中&lt;/li&gt;
&lt;li&gt;点击标签上的X图标或者按退格键删除已选的标签，被删除的标签会回到原来待选标签的位置&lt;/li&gt;
&lt;li&gt;输入框可以输入标签文字后按回车键、空格键或者输入框失去焦点时自动生成标签&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="关于前端" scheme="https://blog.hhking.cn/categories/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://blog.hhking.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="jQuery" scheme="https://blog.hhking.cn/tags/jQuery/"/>
    
      <category term="tags" scheme="https://blog.hhking.cn/tags/tags/"/>
    
  </entry>
  
  <entry>
    <title>之前写的一些东西--简单图片轮播·jQuery小应用·PSD稿还原</title>
    <link href="https://blog.hhking.cn/2015/03/23/20150323/"/>
    <id>https://blog.hhking.cn/2015/03/23/20150323/</id>
    <published>2015-03-23T12:35:13.000Z</published>
    <updated>2018-07-30T06:58:22.188Z</updated>
    
    <content type="html"><![CDATA[<p>之前写过的一些小东西，虽然简单也挺挫的，还是mark一下吧。</p><ul><li><strong>jQuery实现的图片轮播</strong><blockquote><p>1.实现图片的自动播放<br>2.鼠标放在圆点标签上可显示相应图片并停止轮播<br>3.移开鼠标之后继续自动轮播</p></blockquote></li></ul><a id="more"></a><p><a href="http://calltesting.sinaapp.com/imgslide/slide.html" target="_blank" rel="noopener">DemoOne</a> </p><p>实现的不是特别完美，当初写的有点乱，用的方法也比较傻，有些问题有待改进。</p><ul><li><strong>jQuery小应用</strong><blockquote><p>1.实现条目的增加，修改，计数<br>2.当修改条目名称为空时，弹窗提示删除或重新修改</p></blockquote></li></ul><p>主要是通过对整个list绑定click事件，获取click事件的target并以此获取需要修改的目标元素。</p><p><a href="http://calltesting.sinaapp.com/jstest/jstest.html" target="_blank" rel="noopener">DemoTwo</a></p><ul><li><strong>PSD稿还原</strong><blockquote><p>1.对PSD设计稿进行还原<br>2.对IE6进行了兼容性测试<br>3.包含了图片轮播</p></blockquote></li></ul><p><a href="http://calltesting.sinaapp.com/" target="_blank" rel="noopener">DemoThree</a><br>代码写的挺乱的，现在暂时不想去重写了。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前写过的一些小东西，虽然简单也挺挫的，还是mark一下吧。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;jQuery实现的图片轮播&lt;/strong&gt;&lt;blockquote&gt;
&lt;p&gt;1.实现图片的自动播放&lt;br&gt;2.鼠标放在圆点标签上可显示相应图片并停止轮播&lt;br&gt;3.移开鼠标之后继续自动轮播&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="关于前端" scheme="https://blog.hhking.cn/categories/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://blog.hhking.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="jQuery" scheme="https://blog.hhking.cn/tags/jQuery/"/>
    
      <category term="图片轮播" scheme="https://blog.hhking.cn/tags/%E5%9B%BE%E7%89%87%E8%BD%AE%E6%92%AD/"/>
    
  </entry>
  
  <entry>
    <title>从Wordpress迁移到Hexo</title>
    <link href="https://blog.hhking.cn/2015/03/23/%E8%BF%81%E7%A7%BB%E5%88%B0hexo/"/>
    <id>https://blog.hhking.cn/2015/03/23/迁移到hexo/</id>
    <published>2015-03-23T08:36:57.000Z</published>
    <updated>2018-07-31T01:38:38.112Z</updated>
    
    <content type="html"><![CDATA[<p>今天花了好长时间，终于把博客从wordpress迁移到了hexo，托管在github。<br>其实是想试试怎么弄。所以也把wordpress仅有的两篇导入到hexo了。<br>先是安装<br>    1.node.js<br>    2.git<br>然后配置ssh keys，再到建立博客，复制主题，再做了一些小小的修改。<br><a id="more"></a><br>还是有很多不是很满意。希望以后能自己再修改整理，适合自己。<br>主要是先了解一下大致的流程，就像发这个文章一样。<br>有时间再做详细说明吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天花了好长时间，终于把博客从wordpress迁移到了hexo，托管在github。&lt;br&gt;其实是想试试怎么弄。所以也把wordpress仅有的两篇导入到hexo了。&lt;br&gt;先是安装&lt;br&gt;    1.node.js&lt;br&gt;    2.git&lt;br&gt;然后配置ssh keys，再到建立博客，复制主题，再做了一些小小的修改。&lt;br&gt;
    
    </summary>
    
      <category term="浮生若梦" scheme="https://blog.hhking.cn/categories/%E6%B5%AE%E7%94%9F%E8%8B%A5%E6%A2%A6/"/>
    
    
      <category term="博客" scheme="https://blog.hhking.cn/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="文章" scheme="https://blog.hhking.cn/tags/%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>雅​虎​关​于​性​能​优​化​的​35条​军​规</title>
    <link href="https://blog.hhking.cn/2015/03/22/yahuo/"/>
    <id>https://blog.hhking.cn/2015/03/22/yahuo/</id>
    <published>2015-03-22T10:27:22.000Z</published>
    <updated>2018-07-30T06:56:06.444Z</updated>
    
    <content type="html"><![CDATA[<p>原文连接：<a href="https://wubiaoqing.github.io/2014/04/15/%E9%9B%85%E2%80%8B%E8%99%8E%E2%80%8B%E5%85%B3%E2%80%8B%E4%BA%8E%E2%80%8B%E6%80%A7%E2%80%8B%E8%83%BD%E2%80%8B%E4%BC%98%E2%80%8B%E5%8C%96%E2%80%8B%E7%9A%84%E2%80%8B35%E6%9D%A1%E2%80%8B%E5%86%9B%E2%80%8B%E8%A7%84/" target="_blank" rel="noopener">感谢无表情</a></p><p><strong>1、尽量减少HTTP请求个数——须权衡</strong></p><p>合并图片（如css sprites，内置图片使用数据）、合并CSS、JS，这一点很重要，但是要考虑合并后的文件体积。</p><p><strong>2、使用CDN（内容分发网络）</strong></p><p>这里可以关注CDN的三类实现：镜像、高速缓存、专线，以及智能路由器和负载均衡；<br><a id="more"></a></p><p><strong>3、为文件头指定Expires或Cache-Control，使内容具有缓存性。</strong></p><p>区分静态内容和动态内容，避免以后页面访问中不必要的HTTP请求。</p><p><strong>4、避免空的src和href</strong></p><p>留意具有这两个属性的标签如link，script，img，iframe等；</p><p><strong>5、使用gzip压缩内容</strong></p><p>Gzip压缩所有可能的文件类型以来减少文件体积</p><p><strong>6、把CSS放到顶部</strong></p><p>实现页面有秩序地加载，这对于拥有较多内容的页面和网速较慢的用户来说更为重要，同时，HTML规范清楚指出样式表要放包含在页面的&lt;head /&gt;区域内；</p><p><strong>7、把JS放到底部</strong></p><p>HTTP/1.1 规范建议，浏览器每个主机名的并行下载内容不超过两个，而问题在于脚本阻止了页面的平行下载，即便是主机名不相同</p><p><strong>8、避免使用CSS表达式</strong></p><p>页面显示和缩放，滚动、乃至移动鼠标时，CSS表达式的计算频率是我们要关注的。可以考虑一次性的表达式或者使用事件句柄来代替CSS表达式。</p><p><strong>9、将CSS和JS放到外部文件中</strong></p><p>我们需要权衡内置代码带来的HTTP请求减少与通过使用外部文件进行缓存带来的好处的折中点。</p><p><strong>10、减少DNS查找次数</strong></p><p>我们需要权衡减少 DNS查找次数和保持较高程度并行下载两者之间的关系。</p><p><strong>11、精简CSS和JS</strong></p><p>目的就是减少下载的文件体积，可考虑压缩工具JSMin和YUI Compressor。</p><p><strong>12、避免跳转</strong></p><p>为了确保“后退”按钮可以正确地使用，使用标准的 3XXHTTP状态代码；同域中注意避免反斜杠 “/” 的跳转；<br>跨域使用 Alias或者 mod_rewirte建立 CNAME（保存一个域名和另外一个域名之间关系的DNS记录）</p><p><strong>13、剔除重复的JS和CSS</strong></p><p>重复调用脚本，除了增加额外的HTTP请求外，多次运算也会浪费时间。在IE和Firefox中不管脚本是否可缓存，它们都存在重复运算JavaScript的问题。</p><p><strong>14、配置ETags</strong></p><p>Entity tags（ETags）（实体标签）是web服务器和浏览器用于判断浏览器缓存中的内容和服务器中的原始内容是否匹配的一种机制（“实体”就是所说的“内 容”，包括图片、脚本、样式表等），是比last-modified date更更加灵活的机制，单位时间内文件被修过多次，Etag可以综合Inode(文件的索引节点(inode)数)，MTime(修改时间)和Size来精准的进行判断，避开UNIX记录MTime只能精确到秒的问题。 服务器集群使用，可取后两个参数。使用ETags减少Web应用带宽和负载。</p><p><strong>15、使AJAX可缓存</strong></p><p>利用时间戳，更精巧的实现响应可缓存与服务器数据同步更新。</p><p><strong>16、尽早刷新输出缓冲</strong></p><p>尤其对于css，js文件的并行下载更有意义</p><p><strong>17、使用GET来完成AJAX请求</strong></p><p>当使用XMLHttpRequest时，浏览器中的POST方法是一个“两步走”的过程：首先发送文件头，然后才发送数据。在url小于2K时使用GET获取数据时更加有意义。</p><p><strong>18、延迟加载</strong></p><p>确定页面运行正常后，再加载脚本来实现如拖放和动画，或者是隐藏部分的内容以及折叠内容等。</p><p><strong>19、预加载</strong></p><p>关注下无条件加载，有条件加载和有预期的加载。</p><p><strong>20、减少DOM元素个数</strong></p><p>使用更适合或者在语意是更贴切的标签，要考虑大量DOM元素中循环的性能开销。</p><p><strong>21、根据域名划分页面内容</strong></p><p>很显然， 是最大限度地实现平行下载</p><p><strong>22、尽量减少iframe的个数</strong></p><p>考虑即使内容为空，加载也需要时间，会阻止页面加载，没有语意，注意iframe相对于其他DOM元素高出1-2个数量级的开销，它会在典型方式下阻塞onload事件，IE和Firefox中主页面样式表会阻塞它的下载。</p><p><strong>23、避免404</strong></p><p>HTTP请求时间消耗是很大的，有些站点把404错误响应页面改为“你是不是要找_*_”，这虽然改进了用户体验但是同样也会浪费服务器资源（如数据库等）。最糟糕的情况是指向外部 JavaScript的链接出现问题并返回404代码。首先，这种加载会破坏并行加载；其次浏览器会把试图在返回的404响应内容中找到可能有用的部分当作JavaScript代码来执行。</p><p><strong>24、减少Cookie的大小</strong></p><p>去除不必要的coockie<br>使coockie体积尽量小以减少对用户响应的影响<br>注意在适应级别的域名上设置coockie以便使子域名不受影响<br>设置合理的过期时间。较早地Expire时间和不要过早去清除coockie，都会改善用户的响应时间。</p><p><strong>25、使用无cookie的域</strong></p><p>确定对于静态内容的请求是无coockie的请求。创建一个子域名并用他来存放所有静态内容。</p><p><strong>26、减少DOM访问</strong></p><p>缓存已经访问过的有关元素<br>线下更新完节点之后再将它们添加到文档树中<br>避免使用JavaScript来修改页面布局</p><p><strong>27、开发智能事件处理程序</strong></p><p>有时候我们会感觉到页面反应迟钝，这是因为DOM树元素中附加了过多的事件句柄并且些事件句病被频繁地触发。这就是为什么说使用event delegation（事件代理）是一种好方法了。如果你在一个div中有10个按钮，你只需要在div上附加一次事件句柄就可以了，而不用去为每一个按 钮增加一个句柄。事件冒泡时你可以捕捉到事件并判断出是哪个事件发出的。<br>你同样也不用为了操作DOM树而等待onload事件的发生。你需要做的就是等待树结构中你要访问的元素出现。你也不用等待所有图像都加载完毕。<br>你可能会希望用DOMContentLoaded事件来代替 事件应用程序中的onAvailable方法。</p><p><strong>28、用&lt;link&gt;代替@import</strong></p><p>在IE中，页面底部@import和使用&lt;link&gt;作用是一样的，因此最好不要使用它。</p><p><strong>29、避免使用滤镜</strong></p><p>完全避免使用AlphaImageLoader的最好方法就是使用PNG8格式来代替，这种格式能在IE中很好地工作。如果你确实需要使用 AlphaImageLoader，请使用下划线_filter又使之对IE7以上版本的用户无效。</p><p><strong>30、优化图像</strong></p><p>尝试把GIF格式转换成PNG格式，看看是否节省空间。在所有的PNG图片上运行pngcrush（或者其它PNG优化工具）</p><p><strong>31、优化CSS Spirite</strong></p><p>在Spirite中水平排列你的图片，垂直排列会稍稍增加文件大小；<br>Spirite中把颜色较近的组合在一起可以降低颜色数，理想状况是低于256色以便适用PNG8格式；<br>便于移动，不要在Spirite的图像中间留有较大空隙。这虽然不大会增加文件大小但对于用户代理来说它需要更少的内存来把图片解压为像素地图。 100×100的图片为1万像素，而1000×1000就是100万像素。</p><p><strong>32、不要在HTML中缩放图像——须权衡</strong></p><p>不要为了在HTML中设置长宽而使用比实际需要大的图片。如果你需要：</p><p>&lt;img width=”100″ height=”100″ src=”mycat.jpg” alt=”My Cat” /&gt;</p><p>那么你的图片（mycat.jpg）就应该是100×100像素而不是把一个500×500像素的图片缩小使用。这里在下文有更有趣的分析。</p><p><strong>33、favicon.ico要小而且可缓存</strong></p><p>favicon.ico是位于服务器根目录下的一个图片文件。它是必定存在的，因为即使你不关心它是否有用，浏览器也会对它发出请求，因此最好不要返回一 个404 Not Found的响应。由于是在同一台服务器上，它每被请求一次coockie就会被发送一次。这个图片文件还会影响下载顺序，例如在IE中当你在 onload中请求额外的文件时，favicon会在这些额外内容被加载前下载。</p><p>因此，为了减少favicon.ico带来的弊端，要做到：<br>文件尽量地小，最好小于1K<br>在适当的时候（也就是你不要打算再换favicon.ico的时候，因为更换新文件时不能对它进行重命名）为它设置Expires文件头。你可以很安全地 把Expires文件头设置为未来的几个月。你可以通过核对当前favicon.ico的上次编辑时间来作出判断。<br>Imagemagick可以帮你创建小巧的favicon。</p><p><strong>34、保持单个内容小于25K</strong></p><p>因为iPhone不能缓存大于25K的文件。注意这里指的是解压缩后的大小。由于单纯gizp压缩可能达不要求，因此精简文件就显得十分重 要。</p><p><strong>35、打包组件成复合文本</strong></p><p>页面内容打包成复合文本就如同带有多附件的Email，它能够使你在一个HTTP请求中取得多个组件（切记：HTTP请求是很奢侈的）。当你使用这条规 则时，首先要确定用户代理是否支持（iPhone就不支持）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文连接：&lt;a href=&quot;https://wubiaoqing.github.io/2014/04/15/%E9%9B%85%E2%80%8B%E8%99%8E%E2%80%8B%E5%85%B3%E2%80%8B%E4%BA%8E%E2%80%8B%E6%80%A7%E2%80%8B%E8%83%BD%E2%80%8B%E4%BC%98%E2%80%8B%E5%8C%96%E2%80%8B%E7%9A%84%E2%80%8B35%E6%9D%A1%E2%80%8B%E5%86%9B%E2%80%8B%E8%A7%84/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;感谢无表情&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、尽量减少HTTP请求个数——须权衡&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;合并图片（如css sprites，内置图片使用数据）、合并CSS、JS，这一点很重要，但是要考虑合并后的文件体积。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、使用CDN（内容分发网络）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里可以关注CDN的三类实现：镜像、高速缓存、专线，以及智能路由器和负载均衡；&lt;br&gt;
    
    </summary>
    
      <category term="关于前端" scheme="https://blog.hhking.cn/categories/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://blog.hhking.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="性能优化" scheme="https://blog.hhking.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>轻轻地，我来了。</title>
    <link href="https://blog.hhking.cn/2015/03/10/the-start-of-my-blog-welcome/"/>
    <id>https://blog.hhking.cn/2015/03/10/the-start-of-my-blog-welcome/</id>
    <published>2015-03-10T03:20:16.000Z</published>
    <updated>2018-07-27T10:31:07.665Z</updated>
    
    <content type="html"><![CDATA[<p>轻轻地，我来了。</p><p>我白天是个邮递员，晚上就是个有抱负的演员。我住在羊城，希望有条叫做 Jack 的狗。</p><p>这是我的博客，一切从这里开始。</p><p>轻轻地，我来了。希望不会轻轻地走。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;轻轻地，我来了。&lt;/p&gt;
&lt;p&gt;我白天是个邮递员，晚上就是个有抱负的演员。我住在羊城，希望有条叫做 Jack 的狗。&lt;/p&gt;
&lt;p&gt;这是我的博客，一切从这里开始。&lt;/p&gt;
&lt;p&gt;轻轻地，我来了。希望不会轻轻地走。&lt;/p&gt;

      
    
    </summary>
    
      <category term="浮生若梦" scheme="https://blog.hhking.cn/categories/%E6%B5%AE%E7%94%9F%E8%8B%A5%E6%A2%A6/"/>
    
    
      <category term="About" scheme="https://blog.hhking.cn/tags/About/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://blog.hhking.cn/2015/03/10/hello-world/"/>
    <id>https://blog.hhking.cn/2015/03/10/hello-world/</id>
    <published>2015-03-10T03:10:16.000Z</published>
    <updated>2018-07-27T10:31:07.646Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a><br><a id="more"></a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;http://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;http://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;http://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;http://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Writing&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="说明" scheme="https://blog.hhking.cn/categories/%E8%AF%B4%E6%98%8E/"/>
    
    
  </entry>
  
</feed>
